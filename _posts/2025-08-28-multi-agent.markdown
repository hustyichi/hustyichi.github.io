---
layout: post
title: "来自工业界的多 Agent 框架最全细节对比"
subtitle:   "The most complete comparison of multi-agent frameworks from the industry"
date:       2025-08-28 17:00:00
author:     "Bryan"
header-mask: 0.3
catalog:    true
tags:
    - llm
    - agent
---

## 背景介绍
过去的项目涉及 RAG 比较多，在 2024 年整理过 [来自工业界的开源知识库 RAG 项目最全细节对比](https://zhuanlan.zhihu.com/p/707842657)，得到了不少工程师比较好的反馈。最近新项目使用的多 Agent 的技术方案，实际对多 Agent 框架进行了详细了调研，结合最近的项目的具体实践，整理相关内容分享在这边，期望对其他人的框架选型有一些帮助。

在这篇文章中主要对比目前相对成熟或好评较多的多 Agent 框架，主要对比的框架包括 CrewAI、AutoGen、LangGraph、Agno、OpenAI Agents、Pydantic AI、MetaGPT。

如果只关心技术选型结论，可以直接跳到最后结论部分


## 项目基本情况

框架的基本情况的比较如下所示：

| 项目 |  Star 数量 | 持续维护性 | 社区活跃度 | 上手门槛 |
| --- |  --- | --- | --- | --- |
| [CrewAI](https://github.com/crewAIInc/crewAI) | 36.2k | ⭐️⭐⭐️️ | ⭐️⭐️⭐️ | ⭐️ |
| [AutoGen](https://github.com/microsoft/autogen) | 49.2k | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ |
| [LangGraph](https://github.com/langchain-ai/langgraph) | 17.8k | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ |
| [Agno](https://github.com/agno-agi/agno) | 32.4k | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ | ⭐️ |
| [OpenAI Agents](https://github.com/openai/openai-agents-python) | 14k | ⭐️⭐️️⭐️️ | ⭐️⭐️⭐️ | ⭐️⭐️ |
| [Pydantic AI](https://github.com/pydantic/pydantic-ai) | 11.9k | ⭐️⭐️⭐️ | ⭐️⭐️⭐️ | ⭐️⭐️️ |
| [MetaGPT](https://github.com/FoundationAgents/MetaGPT) | 58.1k | ⭐️⭐️️ | ⭐️⭐⭐️ | ⭐️⭐️⭐️ |

- 项目热度而言，因为剔除了一些相对冷门的多 Agent 框架，基本上热度都比较高，Star 数量最少的也有接近 12k 的 star
- 项目可维护性上，MetaGPT 虽然 Star 数量最多，但是更新频率明显下降，有概率后续不会持续迭代和维护，其他项目依旧在持续高频迭代，从当前来看可维护性基本都是有保障的。
- 项目的上手门槛比较，CrewAI 和 Agno 上手门槛比较低，可以快速上手。LangGraph 基于图的抽象，上手门槛相对较高，AutoGen 涉及概念较多，上手门槛也不低。OpenAI-Agent 和 Pydantic AI 上手门槛适中。
- 匹配场景，MetaGPT 主要用于软件开发的场景，其他多 Agent 框架基本是面向通用场景设计的。

根据现有情况来看，除非针对的是软件开发领域，选型基本可以排除掉 MetaGPT。不考虑业务的情况下，可以根据上手门槛进行一些选择。


## 框架核心能力比较
为了确认多 Agent 框架的核心能力与适用场景，针对每个框架的关键能力进行梳理，主要关注的能力维度包括：

- **Agent 建模能力**: 关注的是框架对 Agent 的抽象能力，是否支持 `Reasoning`（推理）、`Planning`（规划）等能力，以及是否可以灵动地自定义 Agent 的行为、推理逻辑和决策过程。
- **协调与通信能力**：关注的是框架中的 Agent 交互能力， 是简单的顺序链式调用，还是复杂的DAG、黑板模式、订阅发布模式。Agent 之间是如何进行通信的。
- **会话与状态管理能力**：关注的是框架中记忆机制以及会话管理，复杂的业务流程需要有相对复杂的状态管理机制进行支撑。
- **工具生态与集成能力**：关注的是框架提供的外部工具调用能力，内置工具的丰富性以及自定义工具的便捷性。
- **LLM 兼容性**：关注的是框架是否支持多种大模型，以及切换模型供应商的便捷性。
- **可观测性**：是否提供良好的可观测能力，方便进行复杂流程的问题定位以及系统调优；
- **可靠性与容错机制**：关注大模型调用失败或核心组件调用失败时，是否提供重试、降级、超时等机制。

### Agent 建模能力
具体的能力比较如下所示：

| 框架             | 核心建模理念                               | 推理/规划支持                                          | 自定义灵活性                                     |
| :--------------- | :----------------------------------------- | :----------------------------------------------------- | :----------------------------------------------- |
| **CrewAI**       | **角色驱动**，预制团队协作模式        | 内置**分层规划**（Hierarchical Planning）          | **中高**（角色、目标、工具易定义，底层推理逻辑依赖模型） |
| **AutoGen**      | **对话驱动**，智能体通过自然语言交谈协作 | 通过**多轮对话**自然涌现，支持 `Reflection` 和自我修正 | **高**（可精细控制对话流程、工具使用、人类干预点）   |
| **LangGraph**    | **图状态机**，将工作流抽象为有向图     | **极灵活**（需手动构建所有推理步骤和状态迁移）         | **极高**（近乎无限，但需自行实现很多底层逻辑）     |
| **Agno**         | **开发者友好**，强调简单直观的 API 设计           | 依赖模型能力，框架提供基础构建块                       | **中**（易于上手，但深层定制可能受限）               |
| **OpenAI Agents**| **黑盒服务**，OpenAI 提供的基础 Agent 能力        | 由 OpenAI 基础设施支持，用户定义目标而非具体步骤           | **低**（行为主要由 OpenAI 的模型和基础设施决定）     |
| **Pydantic AI**  | **模型验证驱动**，集成 Pydantic 用于数据校验 | 依赖模型自身能力，框架侧重于结构化输入输出和工具调用     | **中**（通过 Pydantic Model 定义行为边界，逻辑依赖模型） |


### 协调与通信能力
具体能力如下所示：

| 框架名称         | 核心协调模式                                  | 典型通信机制           | 状态管理方式       | 适用场景                                      |
| :--------------- | :-------------------------------------------- | :--------------------- | :----------------- | :-------------------------------------------- |
| **CrewAI**       | 结构化角色分工，**顺序/层级**协作         | 通过**任务输出**传递     | 隐式任务状态       | 角色明确的**团队任务** (如内容创作、市场分析)    |
| **AutoGen**      | **多Agent对话**与协作，支持**动态交互**   | **消息传递** (聊天模型) | 对话历史记录       | **研究型**、复杂问题解决、**代码生成**       |
| **LangGraph**    | **有向状态图** (DAG), **支持循环与条件分支**  | 通过**共享状态**         | **显式全局状态**   | **复杂、多步骤工作流**，需状态持久化与回溯    |
| **Agno**         | 具体协调模式需查阅其最新文档                  | 具体通信机制需查阅其最新文档 | 具体状态管理需查阅其最新文档 | 强调开发者体验，**快速构建**代理系统         |
| **OpenAI Agents** | 推测为**集中式规划与分配**                    | 推测为**中心协调器调度** | 推测为**中心化管理** | 依托OpenAI生态系统，具体能力及模式需关注官方更新    |
| **Pydantic AI**  | 关注**数据流与验证**，协调能力非核心重点   | 通过**结构化数据**       | **类型化状态**     | **数据密集型应用**，需**严格输出验证**       |


### 会话与状态管理能力


| 框架名称 | 核心记忆机制 | 状态持久化能力 | 上下文共享/传递 | 独特优势 |
| :--- | :--- | :--- | :--- | :--- |
| **CrewAI** | 短期记忆（上下文窗口）、向量数据库（长期） | 支持外部数据库集成，状态可持久化 | `SharedContext` 实现智能体间状态共享 | **智能体作为原子单位**，统一接口 (`kickoff`)，生命周期封装完善，企业级应用支持好 |
| **AutoGen** | 智能体内部状态（对话历史、模型上下文） | 支持状态的保存与加载 (`save_state`/`load_state`) | 通过群聊管理器（`GroupChat`)协调多智能体对话 | **状态序列化能力强大**，可自定义状态保存与加载行为，适合复杂、可恢复的多轮协作 |
| **LangGraph** | **分层记忆架构**（短期线程记忆 + 长期记忆存储） | **检查点（Checkpointer）** 机制自动持久化状态，支持随时恢复 | 状态（State）在整个图中流转，是智能体间通信的核心 | **图状态机模型**，支持循环、分支、人工干预，**持久化与可观测性生产级支持**最好 |
| **Agno** | 短期记忆（SQLite/Redis）、长期记忆（向量数据库） | Mem0记忆管理工具包（存储、检索、分类、时效控制） | 通过`Team`组建专业化团队，明晰分工与协作流程 | **高性能、低延迟**，**人机协作（Human-in-the-loop）** 流程控制（确认、输入、外部执行）是其亮点 |
| **Pydantic-AI** | 模型状态、会话状态 | **内置状态序列化/反序列化**，支持多种后端（内存、文件、DB） | - (更侧重于单一智能体的状态安全) | **类型安全的状态管理**，与Pydantic模型深度集成，确保状态数据的**结构化和验证** |
| **OpenAI Agents** | 主要依赖外部实现或上层框架 | 主要依赖外部实现或上层框架 | 主要依赖外部实现或上层框架 | 提供**Assistants API**，内置**线程（Thread）** 概念管理会话状态，但更偏重于基础能力，复杂协作需自行构建或结合其他框架 |


### 工具生态与集成能力

| 框架名称         | 工具调用方式                                                              | 自定义工具难度 | 内置工具丰富度								 | 特色工具集成能力                                                                                              | 核心优势                                                                 |
| :--------------- | :-------------------------------------------------------------------- | :------------- | :------------- | :-------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------- |
| **CrewAI**       | 灵活的 `@tool` 装饰器，支持 `result_as_answer` 参数控制输出         | 低             | 中等           | 强大的**自定义Agent适配器** (BaseAgentAdapter, BaseToolAdapter)，可集成不同来源的Agent和工具                | **异构Agent集成**，适合混合技术栈和渐进式迁移                             |
| **AutoGen**      | **声明式HTTP工具**（通过JSON Schema定义），**MCP服务器集成** (Model Context Protocol) | 中等           | 丰富           | 原生支持**多模型后端**（OpenAI, Azure, Bedrock, Gemini等），可通过Semantic Kernel桥接扩展        | **企业级API集成**与多模型支持，适合复杂业务系统                      |
| **LangGraph**    | 作为**状态图节点**集成，工具调用是工作流的一部分                           | 中到高         | 依赖LangChain生态 | 可构建**多Agent协作工具流**，支持复杂条件逻辑与循环                                                    | **复杂、可编排的工具工作流**，适合长流程、高自定义场景                   |
| **Agno**         | **工具集参数**传入，支持异步执行和结果验证                               | 低             | 丰富（20+知识连接器） | **多模态工具**（处理文本、图像、音频）, **混合搜索**（向量+关键词）, 预置DuckDuckGo搜索、YFinance等工具 | **开箱即用的工具链**，知识管理能力强，适合快速构建知识密集型Agent                      |
| **OpenAI Agents** | 通过 **`MCPServerStdio`** 集成MCP工具                              | 低             | 依赖MCP服务器      | 自动**工具列表缓存** (`cache_tools_list=True`)，支持远程MCP服务器                                       | **轻量级**，与OpenAI生态系统**无缝集成**，开发体验简洁                           |
| **Pydantic AI**  | 主要关注**模型调用与结构化输出**，工具生态相关信息较少                                 | -              | -              | 强调通过**Pydantic模型**定义和验证工具的输出                                                           | **类型安全**的工具输出处理                                          |


### LLM 兼容性

| 框架名称         | 核心LLM支持特点                                   | 官方明确支持的模型/API                                        | 切换便捷性                                 | 配置灵活性                                   |
| :--------------- | :------------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------- | :------------------------------------------- |
| **CrewAI**       | 原生支持多模型，设计友好                     | OpenAI, Anthropic, Ollama (本地模型), 通义千问, 文心一言等 | **高**，代码配置简单                         | **高**，支持每个Agent独立配置模型            |
| **AutoGen**      | 围绕API设计，需配置模型列表                   | 所有提供 **OpenAI API兼容接口** 的模型（包括Azure OpenAI）   | **中高**，需统一接口，配置稍复杂             | **中**，Group内Agent通常需同源模型          |
| **LangGraph**    | 极度灵活，模型作为图中的一个组件                 | **任意模型** (通过LangChain或自定义集成)            | **高**，但需自行实现集成                   | **极高**，每个节点可使用不同模型           |
| **Agno**         | 新兴框架，强调模型不可知论                        | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档）         | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档） | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档） |
| **OpenAI Agents** | **仅支持OpenAI模型**                              | 仅限于 **OpenAI 自家模型** (如 GPT-4o)                  | **低**，无法切换                           | **低**，深度绑定OpenAI生态系统              |
| **Pydantic AI**  | 设计核心支持多模型                                | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档）         | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档） | （由于其较新，搜索结果中未明确提及，需查阅其最新官方文档） |



### 可观测性

| 框架名称       | 是否提供良好可观测性 | 细节说明 |
|----------------|----------------------|----------|
| CrewAI        | 是                  | 支持通过 Langfuse、W&B Weave、Datadog、Phoenix 和 Maxim AI 等集成实现全面观测，包括代理性能跟踪、瓶颈识别和调试，支持生产环境问题定位和优化。 |
| AutoGen       | 是                  | 集成 AgentOps、Langfuse 和 MLflow 等工具，可监控 LLM 调用、成本、延迟、多代理交互和故障，便于复杂多代理系统的调试和调优。 |
| LangGraph     | 是                  | 内置 LangSmith 支持观测，包括工作流可视化、跟踪和评估，便于调试代理轨迹和生产监控，强调人类干预和质量控制。 |
| Agno          | 是                  | 支持 Langtrace、Langfuse、Portkey 和 AgentOps 等集成，提供代理推理、工具使用和知识检索的观测，便于生产级多代理系统的监控和调试。 |
| OpenAI Agents | 是                  | 内置跟踪工具，并集成 Datadog 和 Dynatrace，支持可视化代理流、工具调用和模型交互的观测，便于企业级问题定位和优化。 |
| Pydantic AI   | 是                  | 内置 Pydantic Logfire 平台，并支持 Langfuse 和 Arize 集成，提供输入/输出消息、工具使用和结构化输出的观测，便于 LLM 应用的调试和监控。 |



### 可靠性与容错机制

| 框架名称         | 核心可靠性设计理念                                   | 大模型调用容错 (重试/降级/超时)									 | 核心组件容错 (如工具执行、状态管理)                                  | 典型适用场景                                     |
| :--------------- | :------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------- |
| **CrewAI**       | 通过集中式任务编排降低不确定性                     | 支持重试，但降级策略需自定义                                       | 任务级容错，部分上下文保持                                  | 目标明确的多步骤复杂任务协作                             |
| **AutoGen**      | 对话驱动的多Agent协作，依赖冗余和重试                | **✅ 重试机制** (内置)，**✅ 降级策略** (多Agent备份)，**✅ 超时控制** (需配置) | **✅ 错误处理** (内置重试、异常捕获，支持任务回滚)，**✅ 沙箱执行** (Docker容器中隔离运行) | 代码生成、数据分析等需多轮对话和人工干预的场景                 |
| **LangGraph**    | 状态机与持久化保障，通过检查点实现状态回溯和恢复         | 需结合外部工具（如LangChain）实现                                   | **✅ 状态持久化** (检查点)，**✅ 时间旅行** (状态回溯)，**✅ 错误恢复** (从历史检查点重试) | 高可靠性的长周期、复杂状态工作流                           |
| **Agno**         | 强调组件化与边界条件处理                             | 基础重试，其他机制需自定义                                       | **✅ 组件初始化检查** (防御性编程避免空指针等异常)                      | 组件化要求高、需精细控制Agent行为的场景                      |
| **OpenAI Agents** | 依赖Pydantic验证输出，通过验证驱动重试                | **✅ 重试机制** (验证触发)，降级和超时需自定义                          | **✅ 输出验证** (Pydantic模型保障结构正确性，支持复杂业务规则验证)         | 需严格保证输出格式和业务逻辑正确的场景                       |
| **Pydantic-AI**  | **强制结构化输出**作为核心容错策略，通过工具调用约束模型输出 | **✅ 闭环重试** (自动验证-错误反馈-重试)，降级和超时需自定义                | **✅ 输出可靠性** (强制模型调用工具输出结构化数据)，**✅ 数据验证** (Pydantic验证) | 对输出格式和数据类型有严格要求的场景                       |


## 结论


**你的首要目标是什么？**

- 快速搭建原型，验证想法 -> 优先考虑 CrewAI。

- 让一群AI自动聊天、协作来解决问题 -> 优先考虑 AutoGen。

- 构建稳定、可靠、能处理复杂流程的正式产品 -> 优先考虑 LangGraph 或 OpenAI Agents SDK。

- 高度重视数据输出的准确性和结构化 -> 优先考虑 Pydantic AI。

**你的团队技术和资源状况如何？**

- 团队技术能力强，追求极致控制和灵活性 -> LangGraph 是强大而灵活的画布。

- 希望快速上手，降低开发门槛 -> CrewAI、OpenAI Agents SDK 或低代码平台更友好。

- 预算和计算资源敏感 -> 需谨慎评估 AutoGen 的Token消耗。

**项目的复杂度和规模如何？**

- 简单任务或节点数<20的工作流 -> CrewAI 效率更高。

- 非常复杂、节点数>50的长链任务或有状态工作流 -> LangGraph 在失败率和延迟控制上表现更优。
