---
layout: post
title: "为什么大模型 Agent 产品总是无法落地？来自实战派的经验分享（二）"
subtitle:   "Why do large-scale agent products always fail to land? Experience sharing from practical people（2）"
date:       2025-09-09 08:00:00
author:     "Bryan"
header-mask: 0.3
catalog:    true
tags:
    - llm
    - agent
---

## 背景介绍

在之前的文章 [Agent 落地经验分享（一）](https://zhuanlan.zhihu.com/p/1948344616962224589) 中，介绍了 Agent 落地中存在的问题，并给出了一些初步的解决方案。

在这篇文章中，针对 Agent 落地中存在的问题，给出更进一步的详细经验分享，希望对大家的实际的 Agent 产品落地有所帮助。本文主要的内容主要参考自 [12-factor-agents](https://github.com/humanlayer/12-factor-agents?tab=readme-ov-file)。

## 方案选择

在构建 Agent 的方案中，一直存在两种相对差异明显的方案，分别是 Agentic 的方案与 Workflow 的方案。关于这两种方案的的选择一直存在着争论。

**Agentic 方案**

Agentic 的方案强调 Agent 的自主性，属于 Agent-First 的方案，开发者只需要提供好目标以及相应的工具，Agent 就可以自行完成任务。采用此方案最知名的项目是 [AutoGPT](https://github.com/Significant-Gravitas/AutoGPT)，这种方案利用大模型自主规划，执行任务，可以使用通用方案完成不同的任务。

**Workflow 方案**

Workflow 的方案强调业务的流程化，属于 User-First 的方案，开发者根据业务需求，将原始任务抽象为多个步骤，在特定步骤可以使用 Agent 完成。采用此方案相对知名比如之前文章详细介绍过的 [Dify](https://zhuanlan.zhihu.com/p/706381113)，这话方案强调深入理解业务，将业务流程化，必要的情况下引入局部的 Agent 组件完成。

当前两种方案各有优劣，Agentic 方案灵活性更强，但是很容易陷入 80 分很难进一步提升，在严肃场景应用可能会随着场景的复杂度增加而失效。而 Workflow 则可以标准化场景下发挥良好，但是灵活性不足，使用场景相对受限。

在本文中经验，优先考虑的实际应用场景中可靠使用，因此整体的经验建议偏向 Workflow 方案。

## 具体经验

本文介绍的主要是为了在实际的应用场景中落地 Agent 产品的 12 条使用方法或建议，具体如下所示：

#### 1. 将自然语言转换为工具调用

![nl-to-tool-calls](/img/in-post/12-factors-agent/110-natural-language-tool-calls.png)

这是目前 Agent 构建中最常见但是也相当强大的模式，借助大模型提供的自然语言处理能力，将自然语言转换为结构化对象，从而支持后续确定性代码的执行。从而保证整体流程的可控性。

针对这种场景，有一个相对好用的 Agent 框架 [Pydantic AI](https://github.com/pydantic/pydantic-ai)，与其他 Agent 框架建立在大量的抽象之上不同，此框架主要用于提供结构化输出的支持，可以相对方便地串联不同的流程。

#### 2. 掌控自己的 Prompt

![own-your-prompts](/img/in-post/12-factors-agent/120-own-your-prompts.png)

此建议强调要将 Prompt 的控制权掌握在自己手中，从而保证大模型的输出符合预期，不要使用框架提供黑盒 Prompt 封装，保证模块的灵活性与可靠性。


#### 3. 掌控自己的上下文窗口

![context-engineer](/img/in-post/12-factors-agent/130-context-engineer.png)

此建议就引出了行业内目前热议的上下文工程（Context Engineering），将大模型视为无状态函数，良好的输入决定了良好的输出。因此精心构造适配当前场景的上下文是相当重要的，一般情况下上下文包含的内容如下所示：

- 提供给大模型的系统提示；
- 检索的外部数据（比如 RAG）;
- 状态、工具调用、结果或其他历史记录;
- 相关的历史信息与会话（记忆）；
- 结构化输出描述；

当然这是只是相对通用的情况，实际业务中需要根据自身业务特点精心设计合适的信息，保证信息的完整性的情况下，尽可能避免无关的信息，提升信息密度。

#### 4. 将工具视为结构化输出

![tools-as-structured-output](/img/in-post/12-factors-agent/140-tools-are-just-structured-outputs.png)

将工具视为结构化输出，主要用于触发确定性代码的执行。工具调用的整体流程被抽象为：

- 大模型输出结构化的 JSON
- 将输出的 JSON 作为输入执行确定性代码, 比如外部 API 调用
- 捕获输出结构反馈至上下文中

这种模式下，大模型保证结构化的正确性，工具自身保证基于结构化输入的可靠性，执行环节可以被解耦开来。


