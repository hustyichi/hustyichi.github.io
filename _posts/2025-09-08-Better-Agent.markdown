---
layout: post
title: "为什么大模型 Agent 产品总是无法落地？来自实战派的经验分享（一）"
subtitle:   "Why do large-scale agent products always fail to land? Experience sharing from practical people（1）"
date:       2025-09-08 08:00:00
author:     "Bryan"
header-mask: 0.3
catalog:    true
tags:
    - llm
    - agent
---

## 背景介绍

自 2024 年底以来，行业不断有人喊出"2025 年 Agent 元年"的口号，不少大模型公司也开始调整战略方向，纷纷布局 Agent 领域。然而，大半年过去了，Agent 仅在有限领域实现了落地，在更多严肃的应用场景下，Agent 产品的落地效果并不理想。

在新项目中持续进行 Agent 相关产品的开发落地，在探索过程中发现了 Agent 落地的一些关键障碍。结合最近解决问题时整理的资料以及个人实践体会，将相关内容整理于此，希望对大家有所帮助。考虑整体内容偏长，后续会分多个部分进行分享。

## Agent 产品的三大核心问题

Agent 产品落地中存在诸多挑战，Utkarsh Kanwat 在文章 [Why I'm Betting Against AI Agents in 2025](https://utkarshkanwat.com/writing/betting-against-agents) 中总结的三大核心问题，个人认为非常精准：

#### 多步骤下的错误累积

大模型产品与传统软件工程最明显的差异在于，大模型虽然功能强大，但无法保证 100% 的准确率。在 Agent 产品中，这个问题会被显著放大，因为 Agent 需要进行多步骤推理，每个步骤的错误都会累积，导致最终结果的偏差。如下图所示：

![error](/img/in-post/better-agent/error_compounding_graph.svg)

让我们来计算一下。如果 Agent 工作流程中每个步骤的可靠性达到 95%，那么：

- 5 步 = 77% 成功率
- 10 步 = 59% 成功率
- 20 步 = 36% 成功率

可以看到，随着步骤的叠加，成功率会呈指数级下降。这还没有考虑随着步骤增加，上下文激增带来的额外准确率下降问题。在复杂场景下，多步骤的自主运行极其容易失败。

#### Token 消耗的二次方增长

在 Agent 产品中，多步骤任务的 Token 消耗与步骤长度呈现二次方关系。如下图所示：

![token](/img/in-post/better-agent/token_cost_scaling_chart.svg)

这是因为第一步仅包含自身的上下文，第二步需要包含第二步的上下文以及第一步的上下文，第三步需要包含第三步的上下文、第二步的上下文以及第一步的上下文，以此类推。

随着步骤的叠加，Token 消耗会快速爆炸式增长，成本开销也会急剧上升。

#### 工具设计的复杂性挑战

为了让 Agent 产品能够完成实际任务，往往需要为大模型提供合适的工具进行扩展。虽然随着 MCP 等协议的推出，工具调用已经越来越便捷，市场也有了更多开箱即用的工具，但实际的工业级 Agent 所需的工具仍需要自行设计，而工具设计本身就是一个巨大挑战。

- Agent 如何知道工具调用是否部分成功？如何在消耗 Token 的情况下传达复杂的状态变化？
- 数据库查询可能会返回 10,000 行，但 Agent 只需要知道"查询成功，10,000 个结果，这里是前 5 个"。设计这些抽象是一门艺术。
- 当工具出现故障时，Agent 需要哪些信息来恢复？信息太少，系统就会卡住；信息太多，就会浪费上下文。
- 如何处理相互影响的操作？数据库事务、文件锁、资源依赖关系等。

## 解决方案

针对上述问题，目前社区已经提出了一些解决方案，比如前段时间比较热门的上下文工程（Context Engineering），说明行业已经意识到类似问题。Agent 产品的落地不能仅靠大模型自身解决，还需要从传统软件工程以及其他领域寻找解决方案。在 Utkarsh Kanwat 的文章中，提供了以下原则性建议：

- **明确界限**。明确你的 Agent 到底能做什么？它会把什么交给人类或确定性系统？Agent 解决的问题越明确且有限，其复杂性就越容易得到控制，避免无限扩大导致的可靠性与经济性问题。

- **为失败做好准备**。如何处理 20-40% 的 AI 错误情况？你的回滚机制是什么？从我过去的实践经验来看，在 Agent 产品中，失败是常态，需要有相应的机制来处理失败情况。

- **解决 Token 消耗问题**。每次交互的成本是多少？成本如何随使用量变化？无状态通常胜过有状态。针对这个问题，我的感受是需要从实际产品出发，先跟踪系统中的 Token 消耗，确定成本消耗最大的部分，在产品层面（比如限制 Agent 的步骤数、限制 Agent 的上下文长度）以及技术层面（比如使用量化、使用压缩算法）进行叠加优化。

- **可靠性优先于自主性**。用户更信任那些稳定运行的工具，而不是那些偶尔能带来神奇效果的系统。神奇效果只能在演示阶段创造价值，但在真实的工业级应用场景下，可靠性是第一位的，没有人会愿意为偶尔的神奇效果买单。

- **建立在坚实基础之上**。使用人工智能处理困难部分（理解意图、生成内容），但依赖传统软件工程处理关键部分（执行、错误处理、状态管理）。这样可以保证基于大模型处理部分的范围，毕竟 Agent 处理的范围与可靠性息息相关。

## 总结

Agent 产品构建中存在一种思路，就是 Agent-First，强调完全的自主性，人类只需要提供必要的扩展工具以及目标，Agent 就可以自行拆解任务，迭代执行，直到最终完成目标。这个愿景当然是美好的，但在当前的实际落地中，更加明确的工作流程，在必要环节嵌入小型、目标明确、可靠执行的 Agent 才能更容易实现产品落地。
